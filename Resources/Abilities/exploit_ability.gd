# res://Resources/Abilities/exploit_ability.gd
class_name ExploitAbility
extends CardAbility

func _init():
	ability_name = "Exploit"
	description = "If I am attacking the opponent's weakest stat, double my attack"
	trigger_condition = TriggerType.ON_PLAY

func execute(context: Dictionary) -> bool:
	if not can_execute(context):
		return false
	
	var placed_card = context.get("placed_card")
	var grid_position = context.get("grid_position", -1)
	var game_manager = context.get("game_manager")
	
	print("ExploitAbility: Starting execution for card at position ", grid_position)
	
	if not placed_card or grid_position == -1 or not game_manager:
		print("ExploitAbility: Missing required context data")
		return false
	
	# Check if there are any adjacent enemy cards to attack
	var has_adjacent_enemies = check_for_adjacent_enemies(grid_position, placed_card, game_manager)
	
	if not has_adjacent_enemies:
		# No adjacent enemies - exploit opportunity is wasted
		placed_card.set_meta("exploit_used", true)
		print("ExploitAbility: No adjacent enemies - opportunity wasted")
		return false
	else:
		# There are adjacent enemies - exploit will be available for first combat
		print("ExploitAbility: Adjacent enemies found - exploit ready")
		return true

func check_for_adjacent_enemies(position: int, card: CardResource, game_manager) -> bool:
	var grid_size = game_manager.grid_size
	var grid_x = position % grid_size
	var grid_y = position / grid_size
	var card_owner = game_manager.get_owner_at_position(position)
	
	# Check all 4 adjacent positions
	var directions = [
		{"dx": 0, "dy": -1},  # North
		{"dx": 1, "dy": 0},   # East
		{"dx": 0, "dy": 1},   # South
		{"dx": -1, "dy": 0}   # West
	]
	
	for direction in directions:
		var adj_x = grid_x + direction.dx
		var adj_y = grid_y + direction.dy
		var adj_index = adj_y * grid_size + adj_x
		
		# Check if adjacent position is within bounds and occupied
		if adj_x >= 0 and adj_x < grid_size and adj_y >= 0 and adj_y < grid_size:
			if game_manager.grid_occupied[adj_index]:
				var adjacent_owner = game_manager.get_owner_at_position(adj_index)
				# If there's an enemy card, we have a target
				if adjacent_owner != card_owner:
					return true
	
	return false

func can_execute(context: Dictionary) -> bool:
	return true

# Static helper function to check if a card can use exploit
static func can_use_exploit(card: CardResource) -> bool:
	# Check if the card has exploit and hasn't used it yet
	if not card.has_meta("exploit_used"):
		return true
	return not card.get_meta("exploit_used", false)

# Static helper function to mark exploit as used
static func mark_exploit_used(card: CardResource):
	card.set_meta("exploit_used", true)
	print("ExploitAbility: Marked as used for ", card.card_name)

# Static helper function to check if we're attacking the weakest stat
static func is_attacking_weakest_stat(attacking_card: CardResource, defending_card: CardResource, attack_direction: int) -> bool:
	# Get the defense direction (opposite of attack)
	var defense_direction = get_opposite_direction(attack_direction)
	
	# Get the defense value being used
	var defense_value = defending_card.values[defense_direction]
	
	# Find the weakest stat in the defending card
	var weakest_value = defending_card.values[0]
	for i in range(1, defending_card.values.size()):
		if defending_card.values[i] < weakest_value:
			weakest_value = defending_card.values[i]
	
	# Check if we're attacking the weakest stat
	var is_weakest = defense_value == weakest_value
	
	print("ExploitAbility: Defense stat (", defense_value, ") vs Weakest stat (", weakest_value, ") - Is weakest: ", is_weakest)
	
	return is_weakest

# Static helper function to get opposite direction
static func get_opposite_direction(direction: int) -> int:
	match direction:
		0: return 2  # North -> South
		1: return 3  # East -> West
		2: return 0  # South -> North
		3: return 1  # West -> East
		_: return 0  # Default fallback
